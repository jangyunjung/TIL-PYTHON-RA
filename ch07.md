# CHAPTER 07 정리

<df>

### 01. 자료구조의 개념   
특징이 있는 정보를 메모리에 효율적으로 저장 및 반환하는 방법으로 데이터를 관리하는 방식   

### 02. 자료구조

< PREVIEW >

| 자료구조 | 특징 및 기능 |
|:-----:|:------:|
| 스택(stack) | 택배 수하물 쌓듯이 먼저 들어간 데이터가 나중에 나오는 자료구조 |
| 큐(queue) | 선착순처럼 먼저 입력된 값이 먼저 나갈 수 있도록 하는 자료구조 |
| 튜플(tuple) | 리스트와 같지만, 튜플(리스트 자료형)의 요소값을 바꿀 수 없는 자료구조 |
| 세트(set) | 중복을 허용하지 않고 (수학)집합연산을 제공하는 자료구조 |
| 딕셔너리(dictionary) | 데이터를 찾는데에 용이한 키(key)와 실제 데이터인 값(value)의 형태로 값을 저장하는 자료구조로, 여기서 키값은 다른 데이터와의 중복을 허용하지 않음 |
| collection 모듈 | 위 5가지 자료구조를 효율적으로 사용할 수 있도록 하는 파이썬 내장 모듈 |

<df>  

#### 1. 스택(stack _ LIFO : Last In First Out)  
- 마지막에 들어간 데이터가 가장 먼저 나오는 형태의 저장 공간    
(LIFO : Last In First Out)
- 푸시(push) : 스택(저장공간)에 데이터를 저장하는 것
- 팝(pop) : 스택(저장공간)에서 데이터를 추출하는 것
- 택배 수화물(데이터) 싣는 거(먼저 들어가면 제일 나중에 빼야 함)  생각하기
- 파이썬에서는 리스트로 스택 구현함   
( 리스트로 저장공간을 만든 후에   
 append()함수로 데이터를 저장하고, pop()함수로 데이터를 추출함. ) 

```python
< 리스트로 구현한 stack : 파이썬은 리스트로 스택 구현 ! >

# stack_push는 .append()함수로 !   
a = [1,2,3,4,5]
a.append(10)
print(a)
>> [1,2,3,4,5,10]
# stack_push는 .append()함수로 !
a.append(20)
print(a)
>>[1,2,3,4,5,10,20]

# stack_pop은 .pop()함수로 !
a.pop()
>> 20   # 제일 마지막에 넣었던 값만 추출함
a.pop()
>> 10   # 제일 마지막에 넣었던 값만 추출함
print(a)
>> [1,2,3,4,5]
```   

```python 
< 스택 예제 : 입력한 텍스트 역순으로 출력하기 >

def reverse(word):
    word = input('Input a word:')
    list = []  
    #(DON'T)빈 리스트를 함수 밖에서 선언하지도, for문 안에서 선언하지도 않는다.
    #(MUST) 함수 안에서, 그리고 for문 밖에서 선언하도록 한다. 
    for i in word:
        list.append(i)  # push
    print(list)         # 확인용
    for k in list:
        reverse_list = list.pop(k)  #pop
    return reverse_list[::-1]
```

#### 2. 큐 (queue _ FIFO : First In FIrst Out)
- 먼저 들어간 데이터가 먼저 나오는 형태의 데이터 저장공간
- 메모리가 시작하는 지점이 고정된 스택과 달리,   
큐는 처음에 값이 저장되는 메모리 주소가 값이 사용됨에 따라 계속 바뀜. 
- 선착순으로 정보 저장한다고 생각하면 될 듯   

<df>

```pythona
>>> a= [1,2,3,4,5]
>>> a.append(10)
>>> a.append(20)
>>> a.pop(0)
>>> 1
>>> a.pop(0)
>>> 2
```

#### 3. 튜플 (tuple)
- 리스트와 같은 개념이지만, 값을 변경하는 것이 불가능한 리스트
- 튜플 객체가 1개일 때는 ,(콤마)로 반드시 튜플임을 선언해야 함   
(ex. t=(1,) )
- 주로 값이 바뀌어서는 안되는 데이터에 튜플을 많이 활용함  
``` python
>>> t = (1,2,3)  # 튜플 선언 명령문 :  리스트[]와 달리 ()로 선언
>>> print(t+t,t*2)
# 선언 방식 이외의 연산은 리스트와 모두 같은 방식 (리스트 연산, 인덱싱, 슬라이싱)
(1,2,3,1,2,3)(1,2,3,1,2,3)
>>> len(t)
3
```
**** [ 다시 한 번 강조 ]    
튜플의 가장 큰 특징 : 튜플 객체에는 새로운 객체의 할당을 허용하지 않는다. 리스트와 달리,  값의 재할당이 불가하다.

#### 4. 세트 (set)
- 값을 순서 없이 저장하되, 중복을 불허하는 자료형 (수학의 집합 개념과 유사)
```python
< 세트 선언 방법 >
>>> s = set([1,2,3,1,2,3])
# 리스트나 튜플의 데이터를 넣으면 해당값이 세트 형태로 변환됨
>>> s
{1,2,3}  # set()함수로 1,2,3을 세트 객체로 생성
```
- 세트는 튜플과 달리, 삭제나 변경이 가능함
```python
< 이전 코드에 이어서 .. >
>>> s
{1,2,3}
>>> s.add(1)  # 세트인 s에 1을 추가하는 명령이지만,
{1,2,3}       # 중복을 불허하는 세트의 특징에 의해 값이 추가되지 않음

>>> s.remove(1)  # 1 삭제
>>> s
{2,3}

>>> s.update([1,4,5,6,7])   # [1,4,5,6,7] 추가
>>> s              
{1,2,3,4,5,6,7}       # 중복되는 1 빼고 모두 추가됨

>>> s.discard(3)     # 3 삭제
>>> s
{1,2,4,5,6,7} 

>>> s.clear()   # s의 모든 원소 삭제
>>> s
set()       # 비어 있는 세트 출력
```
< 세트 함수 정리 >
| 함수 | 기능 |  
|:------:|:-------:| 
| add() | 원소 하나 추가 |
| remove(), discard() | 원소 하나 제거 |
| update() | 새로운 리스트 그대로 추가 |
| clear() | 모든 변수(요소) 지우기 |

- 집합 연산 (합집합, 교집합, 차집합) 연산 제공
```python 
>>> s1 = set([1,2,3,4,5])
>>> s2 = set([3,4,5,6,7])

>>> s1.union(s2)    # s1과 s2의 합집합
{1,2,3,4,5,6,7}
>>> s1 | s2         # ' | ' : 합집합 기호
{1,2,3,4,5,6,7}

>>> s1.intersection(s2) # s1과 s2의 교집합
{3,4,5}
>>> s1 & s2         # ' & ' : 교집합 기호
{3,4,5}

>>> s1.difference(s2)  # s1과 s2의 차집합
{1,2}
>>> s1 - s2         # ' - ' : 차집합 기호
{1,2} 
```
< 세트 집합 연산 정리 >   

| 연산 | 함수 | 기호 |  
|:------:|:-------:|:-----:| 
| s1과 s2의 합집합 | s1.union(s2) | '|' |
| s1과 s2의 교집합 | s1.intersection(s2) | '&' |
| s1과 s2의 차집합 | s1.difference(s2) | '-' |

#### 5. 딕셔너리 (dictionary)   ******
- 색인을 통해 데이터를 찾기 쉽도록 한 자료구조
- 키(key) : 데이터의 구분자 (데이터를 찾을 때 쓰는 색인)
- 값(value) : 실제 데이터 
- 이때, 데이터 값(value)에는 다양한 데이터 타입이 들어갈 수 있다.    
(ex) 문자열, 정수, 리스트, 튜플, 세트, 딕셔너리 .. 등등
```python
< 딕셔너리 선언 방법>
>>> student_info = {1: 'mary', 2: 'jack', 3: 'linda'}
# 키(key)값에 문자 쓰고 싶으면 '문자' 해야 함

< 딕셔너리에서 값을 호출하는 방법 >
>>> student_info[1]
>>> 'mary'
# 키로 값을 검색하도록 함

< 재할당 >
>>> student_info[1] = 'joshua'
>>> student_info[1]
>>> 'joshua'

< 데이터 추가 >
>>> student_info['a'] = 'david'
>>> student_info['a']
>>> 'david'
>>> student_info
>>> {1: 'joshua', 2: 'jack', 3: 'linda', 'a': 'david'}
# 추가한 데이터는 딕셔너리의 맨 마지막 요소로 추가됨
```
- 딕셔너리 내장함수
```python
# 딕셔너리 키만 출력하는 함수
>>> student_info.keys() 
>>> dict_keys = ([1,2,3,'a'])

# 딕셔너리 값만 출력하는 함수
>>> student_info.values()
>>> dict_values =(['joshua','jack','linda','david'])

# 키와 값을 쌍으로 출력하는 함수
>>> student_info.items()
>>> dict_items([(1,'joshua'),(2,'jack'),(3,'linda'),('a','david')])

# in 함수 : 특정 키나 값이 해당 변수에 있는 지 확인 
>>> 'david' in student_info.values()
True
>>> 1 in student_info.keys()
True
```
- for문이나 if문과 함꼐 사용하는 경우가 많음
 ```python
 # 딕셔너리와 for문
>>> for k,v in student_info.items():
    print ('key:', k)
    print ('value:', v)
...
...
key: a
value: david
key: b
value: jack
key: c
value: linda
key: 1
value: joshua # 출력값

# 딕셔너리와 if문 ***** 예제 찾아봐
>>> 

```


<df>

#### 6. collections 모듈
 
1. deque 모듈
- 스택과 큐를 모두 지원하는 모듈
- 

2. OrderDict 모듈 ( 중요도 : 중하 )
- 원래 dict 는 마음대로 찍을 수 있음. 원래 dict의 순서를 유지하되, 알파벳 순서대로 재정렬할 수 있음.
- 이걸 왜 쓰는 지? : 딕셔너리에 없는 기능을 보완(일반 딕셔너리도 삽입순서를 유지함 _ 파이썬 3.7이후 .. 지금은 과거의 모듈일 뿐 )

3. defaultdict 모듈 _ 딕셔너리로 바꿔서 모듈 작성해보기(코드로)
- 
- 딕셔너리 변수 생성 시 키의 기본값 생성
- 새로운 키 생성 시 별다른 조치없이 새로운 값 생성 가능 
- 새로운 키 값이 없어도 별 다른 오류 발생 X

4. Counter 모듈 ******
- 시퀀스 자료형에서 같은 값이 몇 개 있는 지 딕셔너리 형태로 반환하는 방법 

5. namedtuple 모듈
- 튜플의 형태로 데이터 구조체를 저장하는 방법

### Lab : 텍스트 마이닝 프로그램 (p.264)
```python
< 프로그램 작성 규칙>
- 문장의 단어 개수를 파악하는 코드를 작성한다
- defaultdict 모듈을 사용한다
- 단어 출현 횟수를 기준으로 정렬된 결과를 보여주기 위해 OrderedDict 모듈을 사용한다

``` 

### 연습문제 오답노트 (p.269)
```python
```

모듈을 외우기보다는 모듈을 어떤 상황에서 어떻게 사용하는지, 접근법 위주로 학습하기. print문을 찍어보면서, 책에 있는 코드를 조금 더 변형해서 모듈을 학습하도록

지피티 configure로 이것저것 만들어보기 : ex. 백경종원

과제 할 때 문서 읽히기