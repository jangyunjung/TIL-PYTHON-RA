# CHAPTER 03 정리

## 파이썬 프로그래밍 환경
1. 사용자 인터페이스 (User Interface : UI)
- (ex) 마우스, 아이콘, GUI(Graphical User Interface)

2. CLI 환경 (Command Line Interface)
- (ex) 콘솔, 명령어 창(cmd), 터미널 (맥, 리눅스)

## 화면 입출력
1. 표준 입력 함수 : input()함수
- 콘솔 창에서 사용자의 입력을 받을 수 있는 프로그램
- input()함수가 실행되면, 콘솔 창은 사용자가 입력할 수 있도록 대기 상태가 됨

2. 표준 출력 함수 : print()함수
- 깊이 있게 배우기는 뒤에서 다시 .....
- 여러 값을 연결해 화면에 출력하는 방법 :    
print(a,b)    >>   a와 b의 자료형이 동일한 지 여부는 상관 없음   
print('str1'+'str2') >> str1str2 (띄어쓰기 없이)   
(단, 문자형 간의 합연산에서는 반드시 data type이 문자형이어야 함)

### input()함수 작성 요령
1. input()함수 실행 시, 콘솔 창은 대기 상태이므로, print()로 사용자에게 지시문을 보여주는 게 좋음. 이때,   
print('지시문')   
a = input()
이렇게 써도 좋다.  

2. 하지만, input() 함수 안에 지시문을 쓸 수도 있다.  
temp = float(input('온도 입력하기:'))   
print(temp)   
  
* 이때, 주의사항 : input()함수는 모든 입력값을 문자형(str)으로 받음  

## 파일 입출력 정리
파이썬 : GUI 프로그램보다 CLI 기반 프로그램을 더 많이 개발함   
(물론, GUI를 지원하는 PyQT같은 도구도 존재함)       

## 리스트의 이해
### 1. 리스트가 필요한 이유
일반적으로(C 또는 Java) 배열(array), 파이썬(Python)에서는 리스트(list)라고 하는 자료형으로, 한 개의 변수로 많은 값을 저장할 수 있다는 장점을 가짐.
### 2. 리스트의 개념
+ 시퀀스 자료형(python) : 여러 자료를 순서대로 넣는 자료형이며, 리스트처럼 여러 데이터를 하나의 변수에 저장하는 개념   
+ 리스트에는 하나의 자료형에만 국한되는 게 아니라, 다양한 자료형을 포함시킬 수 있음. (리스트는 시퀀스 자료형의 일종)
+ 파이썬에도 '배열'이라는 별도의 개념이 존재하지만, 주로 시퀀스형 자료형을 처리하기 위해 리스트(list)가 더 많이 쓰임
[시퀀스 자료형 관련 링크 -> 따로 정리하기](https://dojang.io/mod/page/view.php?id=2205)
### 3. 인덱싱과 슬라이싱
1. 인덱싱 ([0],[1],[2], ....)
+ len(list) : list의 길이 즉, 리스트 요소의 개수를 세어주는 함수
2. 슬라이싱 ((***개중요))   
+ 리스트[ 시작 : 끝 : 증가값 ]   
3. 리버스인덱스도 가능   
: 리스트에 인덱스를 거꾸로 매기되, [시작:끝:증가값]라는 슬라이싱 틀은 동일함   
4. 인덱스 범위를 넘어가는 슬라이싱
+ 리스트[:]  : 변수 처음부터 끝까지
+ 리스트 [-100:100] : 범위를 넘어갈 경우 _ 자동으로 최대 범위 지정
5. 증가값(step) : list[시작 : 마지막 : 증가값]
+ 이때, 증가값은 정방향(+)이든, 역방향(-)이든 상관 없다
### 4. 리스트의 연산
1. 덧셈 연산
list1 + list2 >>> 두 리스트 요소들을 합친 새로운 리스트
2. 곱셈 연산
list*2 >>> list 2회 반복
3. in 연산 : 찾고자 하는 값이 해당 리스트에 들어있는지 확인
'you' in list >>> False (또는 True)
### 5. 리스트 추가 및 삭제
1. list.apppend('추가할 새로운 값')   
: list 맨 마지막 인덱스에 새로운 값(**)을 추가함
2. list.extend([새로운 리스트])   
: 리스트의 덧셈 연산처럼 기존 리스트인 list에 새로운 리스트를 합침 
3. insert(인덱스, '추가할 새로운 값')   
: 특정 인덱스에 새로운 값을 추가하면, 그 이후의 인덱스는 한 칸씩 밀림
4. list.remove('지우고자 하는 특정 값')   
: 리스트에서 특정값 삭제
5. list[n] = '바꾸고자 하는 값'   
: 리스트에서 특정 인덱스 값 재할당
6. del list[n]  
: 리스트에서 지우고자 하는 특정 인덱스값 삭제   
( .remove('특정값')은 지우고자 하는 값을 지정해야 하고,   
del list[n]은 지우고자 하는 인덱스값을 지정해야 함 )
### 6. 패킹과 언패킹 (시퀀스 자료형에서 일반적으로 사용하는 개념)
1. 패킹(packing)
: 한 변수에 여러 개의 데이터를 할당하는 그 자체 (리스트 그 자체)     
> t = [1,2,3] : 패킹

2. 언패킹(unpacking)   
: 한 변수에 여러 개의 데이터가 들어있을 때 (변수 t가 리스트를 받았다면) 그 여러 개의 데이터를 각각의 변수로 반환하는 방법
> a,b,c=t : t에 들어있는 1,2,3 각각의 데이터를 변수 a,b,c로 반환

### 7. 이차원 리스트
: 여러 개의 리스트를 하나의 변수에 할당하는 리스트

## 리스트의 메모리 관리방식 
### 1. 리스트의 메모리 저장 방식
리스트를 저장할 때, 값 자체가 아니라 '값이 위치한 메모리 주소'를 저장함   
: (Python) 리스트를 저장할 때, 리스트 요소값 자체가 아닌 '요소값이 위치한 메모리 주소'를 저장함 (질문 Q. -5~256이 리스트의 요소라면, 절대적인 그 메모리 위치가 저장되는 거잖아(정적 메모리). 그럼 'st'와 같은 문자형 데이터나 -5~256을 벗어난 범위의 숫자들은 절대적으로 정해진 메모리 위치가 없음)

##### 메모리, 변수, 값(value) 한 번 더 짚고 넘어가기
- 메모리 위에 값이 올라가 있고, 해당 메모리엔 고유의 주소가 있음. 이를 '메모리 주소'라고 함. 이 때, 변수는 메모리 주소에 올라가 있는 값(value)를 구분해주기 위한 인덱스(포스트잇)같은 역할을 함.  
- (ex) a=300 b=300   
a==b(== : value 비교) >> True   
a is b (is : 메모리의 주소 비교) >> False
- (주의) c=22 b=22
a==b >> True , a is b >> True (-5~256은 메모리 위치가 정해져 있기 때문)  

### 2. 메모리 저장 구조로 인한 리스트의 특징
1. 하나의 리스트에 다양한 자료형(int, str, float, Boolen, list(시퀀스형)) 포함 가능  

2. 리스트 저장 방식   
 : 서로 다른 리스트 a,b가 존재할 때, a를 b에 할당하면, b에는 a의 메모리 주소가 저장됨  
 (ex) a= [5,4,3,2,1], b=[1,2,3,4,5], b=a, a.sort(), print(b)  
 > [1,2,3,4,5] (b에는 a의 메모리 주소가 저장되어 있기에, 오름차순 정렬된 a가 출력됨)


# CHAPTER 04 정리

# 1. 조건문  
1. 개념  
: ~이면(조건), ~하라(실행)  

2. if-else문  

3. 조건의 판단  
- 비교 연산자   (표.. 어케 작성하노.. 일단 대기)   
(==, !=, is, is not, >, <, >=, <=) : 비교상태 읊어보삼

- True 와 False 의 치환  
: 컴퓨터의 이진수 처리로, 'True는 1로, False는 0으로' 처리함.  
또, '존재하면 True, 존재하지 않으면 False' 처리함.
- 논리 연산자 (and, or, but)  

4. if-elif-else문 (중첩if문)
: if문에서 여러 개의 조건을 확인할 수 있음. (elif=else if)  
if - elif - elif - else 이런 틀인데, 조건 성립하면 바로 if문을 빠져나오고, 조건 성립하지 않으면 그 다음 조건으로 넘어가는 형식임.  
 즉, 하나의 조건만 성립하면 다른 조건들과는 비교하지 않음

# 2. 반복문

1. 개념
: 정해진 동작을 반복적으로 수행
   
2. for문 (기본적인 반복문)
- 문법:  
for 변수 in (자료형) : 반복범위 지정  
들여쓰기 후 실행명령  
list, range(n), range(시작번호, 마지막번호, 증가값), '문자열' 을 반복범위로 쓸 수 있음.  

3. while문 (어떤 조건이 만족하는 동안 명령 수행, 해당 조건이 거짓일 경우 더 이상 반복 명령문 수행하지 않음 )
- 문법:   
while 조건 :   
들여쓰기 후 실행명령   
   
###### (!!!) for문 & while문 언제 쓸까용 ??
- 반복실행 횟수를 명확히 알 때 : for문
- 반복실행 횟수가 명확하지 않을 때 : while문   
(while문의 실행종료시점은 '조건에 성립하지 않을 때'니까)
   

4. 반복문의 제어
- break 문    
: 반복문 강제 종료   

- continue 문   
: 특정 조건에서 남은 명령을 건너뛰고 다음 반복문 수행   
   
- else 문    
: 어떤 조건이 완전히 끝났을 때, 실행명령을 원한다면 활용하는 구문.   
 (근데 '굳이'이긴 함 _ 생략 가능)  

# 3. 코드 오류 처리 방법

1. 버그와 디버그
- 버그 : 프로그래밍에서의 오류
- 디버그 : 오류를 수정하는 과정
- 디버깅 : 오류 발견 시, 잘못을 찾아내고 고치는 것

2. 오류의 종류 & 해결 방법
- 문법적 오류 : 들여쓰기, 오탈자로 인한 오류
- 논리적 오류 ( 실습 못해써 _ 실습해라 )
